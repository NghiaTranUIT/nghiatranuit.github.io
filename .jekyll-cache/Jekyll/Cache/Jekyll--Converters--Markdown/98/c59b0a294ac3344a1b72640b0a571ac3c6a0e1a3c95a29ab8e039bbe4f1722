I"c9<p>UITableView is extremely useful class to list content which Apple provide to iOS developer. UITableView use “reusable” pattern to handle content in each cell. So it can contain 100+ row with good performance.</p>

<p>There are many common scenarios when you deal with UITableView.</p>

<p>One of this is load asynchronous content in cell.</p>

<p>Like this</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span><span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span> <span class="nf">tableView</span><span class="p">:(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span> <span class="n">tableView</span> <span class="n">cellForRowAtIndexPath</span><span class="o">:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span> <span class="n">indexPath</span>
<span class="p">{</span>
    <span class="n">MyCustomeCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyCustomeCell</span> <span class="o">*</span><span class="p">)[</span><span class="n">tableView</span> <span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">:</span><span class="s">@"Cell"</span> <span class="nf">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
 
    <span class="c1">// weak cell</span>
    <span class="n">__weak</span> <span class="n">MyCustomeCell</span> <span class="o">*</span><span class="n">weakCell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
    <span class="c1">// Async</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// Get Image</span>
        <span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="c1">// URL link</span>
        <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="nf">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">alloc</span><span class="p">]</span> <span class="n">initWithData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
 
        <span class="c1">// Update UI</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">weakCell</span><span class="p">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But, in this code have some issues memory.</p>

<p>Image you have 100 row, each of row you must load async big UIImage. So before cell is being displayed. TableView will call “Data Source” which provide cell. And in cellForRowAtIndexPath: will fire async method to load content.</p>

<p>But if this cell is OUT of visible area. The async operation you called is <strong>still doing work</strong>. So when this operation update UI in main thread, this UIImage is unnecessary resource. Sometime, it cause some “buggy”.</p>

<p>UITableViewCells are often <strong>reused instances</strong>. This means that cells being loaded into the view may sometimes contain data that was loaded originally into a completely different cell.</p>

<p>So, to handle this common scenarios. I use NSOperation and NSOperationQueue  Apple was introduced NSOperationQueue and many relative class in iOS 4. This was build in top of Grand Dispatch Central. But improve more enhancement. NSOperation can be cancel and resume easily.</p>

<p>In brieft, we will implement step-by-step :</p>

<ol>
  <li>Init array or dictionary</li>
  <li>In cellForRowAtIndexPath:, we will create NSOperationBlock and add to background thread. You must implement how it do if this operation is NOT cancel. Finally, we add to array or dictionary to usable.</li>
  <li>Implement didEndDisplayingCell, this method will be called if cell is OUT of visible area.</li>
  <li>Get operation in arr / dictionary and cancel. And remove out.</li>
</ol>

<p>Here is sample :</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView</span><span class="p">:(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">cellForRowAtIndexPath</span><span class="p">:(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
    <span class="n">MyCustomeCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyCustomeCell</span> <span class="o">*</span><span class="p">)[</span><span class="n">tableView</span> <span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">:</span><span class="s">@"Cell"</span> <span class="nf">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
 
    <span class="c1">// Get URL</span>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="n">_arrURL</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="nf">row</span><span class="p">];</span>
 
    <span class="c1">//Create a block operation for loading the image into the profile image view</span>
    <span class="n">NSBlockOperation</span> <span class="o">*</span><span class="n">loadImageOperation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBlockOperation</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
 
    <span class="c1">//Define weak operation so that operation can be referenced from within the block without creating a retain cycle</span>
    <span class="n">__weak</span> <span class="n">NSBlockOperation</span> <span class="o">*</span><span class="n">weakOperation</span> <span class="o">=</span> <span class="n">loadImageOperation</span><span class="p">;</span>
 
    <span class="p">[</span><span class="n">loadImageOperation</span> <span class="nf">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="c1">//Some asynchronous work. Once the image is ready, it will load into view on the main queue</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:[</span><span class="n">NSData</span> <span class="nf">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">]];</span>
 
        <span class="c1">// Update UI in main thread when completion</span>
        <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="nf">mainQueue</span><span class="p">]</span> <span class="nf">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//Check for cancelation before proceeding. We use cellForRowAtIndexPath to make sure we get nil for a non-visible cell</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">weakOperation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="n">MyCustomeCell</span> <span class="o">*</span><span class="n">theCell</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyCustomeCell</span> <span class="o">*</span><span class="p">)[</span><span class="n">tableView</span> <span class="nf">cellForRowAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
                <span class="n">theCell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
 
                <span class="c1">// Remove operation</span>
                <span class="p">[</span><span class="n">_myDictionary</span> <span class="nf">removeObjectForKey</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}];</span>
    <span class="p">}];</span>
 
    <span class="c1">//Save a reference to the operation in an NSMutableDictionary so that it can be cancelled later on</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="p">[</span><span class="n">_myDictionary</span> <span class="nf">setObject</span><span class="p">:</span> <span class="n">loadImageOperation</span> <span class="nf">forKey</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="c1">//Add the operation to the designated background queue</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loadImageOperation</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">_operationQueue</span> <span class="nf">loadImageOperation</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="c1">//This would be a good place to assign a placeholder image</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">placeholdImage</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and we take advantage in didEndDisplayngCell method.</p>

<p>We will cancel operation which called in cellForRowAtIndexPath: before.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tableView</span><span class="p">:(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">didEndDisplayingCell</span><span class="p">:(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nv">cell</span> <span class="nf">forRowAtIndexPath</span><span class="p">:(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> 
<span class="p">{</span>
    <span class="c1">//Fetch operation that doesn't need executing anymore</span>
    <span class="n">NSBlockOperation</span> <span class="o">*</span><span class="n">ongoingDownloadOperation</span> <span class="o">=</span> <span class="p">[</span><span class="n">_myDictionary</span> <span class="nf">objectForKey</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
 
    <span class="c1">// Ensure ongoingDownloadOperation is not nil</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ongoingDownloadOperation</span><span class="p">)</span> 
   <span class="p">{</span>
        <span class="c1">//Cancel operation and remove from dictionary</span>
        <span class="p">[</span><span class="n">ongoingDownloadOperation</span> <span class="nf">cancel</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_myDictionary</span> <span class="nf">removeObjectForKey</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, this is the best way to handle this scenarios. You can cancel all of operation if you push to new UIViewController.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">viewWillDisappeard</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span> <span class="n">animated</span>
 
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewWillDisappeard</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
 
    <span class="c1">// Cancel all</span>
    <span class="p">[</span><span class="n">_myOperationQueue</span> <span class="nf">cancelAllOpeations</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, you can improve more performance by setting <code class="language-plaintext highlighter-rouge">setMaxConcurrentOperationCount</code>.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">_myOpeationQueue</span> <span class="nf">setMaxConcurrentOperationCount</span><span class="p">:</span><span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>

<p>Feel free for giving me your comment or your opinion.</p>

<p>Thanks for reading ;]</p>

:ET
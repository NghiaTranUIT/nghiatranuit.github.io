I"´è<p>Hi, Today is totallyÂ perfect day to start a newÂ series of Algorithm blog. Since Iâ€™ve learned data structure &amp; algorithm to prepare forÂ next interview. I learnt tons of new amazing things, so I decide to write something for anyone who interestingÂ ğŸ˜‰</p>

<p>Longest Common Subsequence (aka Diff) is classic problem in computer science. Weâ€™re using it everyday, but we didnâ€™tÂ notice. It also widely used by Revision Control System.</p>

<ul>
  <li>When Github figure it out whatâ€™s new line of codes, whatâ€™s removed. They use Diff</li>
  <li>When <a href="https://www.diffchecker.com">DiffChecker</a> Â do comparison. They use Diff.</li>
  <li>Diff Utility use Diff as main core.</li>
</ul>

<p>In another hand,Â diff is also usefulÂ to compare pair ofÂ images.</p>

<ul>
  <li><a href="http://www.kaleidoscopeapp.com">Kaleidoscope</a>Â is able to spot the difference of two images with pixel accuracy, and print it out.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/kaleidoscope.jpg" alt="" /></p>

<ul>
  <li><a href="https://github.com/facebook/ios-snapshot-test-case">Facebook iOS Snapshot Test</a>Â make diff by drawing both of layer/view and reference image, then compare each pair of pointer in memory withÂ the C functionÂ <code class="language-plaintext highlighter-rouge">memcmp().Â </code>This make it extremely quick:Â from 0.013 to 0.086 seconds for fullscreen iPad on Macbook Air (<a href="https://www.objc.io/issues/15-testing/snapshot-testing/">reference</a>)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/snapshots-reference-59b0b96b.png" alt="" /></p>

<ul>
  <li><a href="https://github.com/Instagram/IGListKit">IGListKit</a> is amazing open-source, built from InstagramÂ Engineering team. According from their blog, IGListKit still use improved Diff (Paul Heckelâ€™s algorithm) to calculate and perform insert/move/reload/delete without crashed with <strong>linear time BigO(n)</strong>, itâ€™s really increadible result.</li>
</ul>

<p><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1600/1*7w2BL8pAqAs-qMiDWHLENA.gif?resize=541%2C260&amp;ssl=1" alt="" /></p>

<p>To understand deeply LCS and a apply it to real world. I intent toÂ split into 2 parts.</p>

<p><strong>Part 1:</strong> We will discuss how to implement LSC with <strong>naive solution</strong> and with <strong>Dynamic Programming</strong>, by using Memorization table. I will try to visualize the algorithm of both solution as possible. I will implement by pure swift to make sure everybody can understand before moving to real shit.</p>

<p>The main goal, we will extend Array<Element>. Put more effort, so it can reusable in any kind of array.</Element></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Work with generic array</span>
<span class="c1">// It will work [Any], which Element must adopt with &lt;Equatable&gt; protocol</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{}</span>
</code></pre></div></div>

<p><strong>Part 2:</strong> Itâ€™s real world, we reused the knowledge from part 1.Â Implement Diff, DiffStep to represent each step (insert/delete/reload) need to be transform. Also extend UITableView, UICollectionView to calculate optimize transformation, from old to new Data Source</p>

<p>The goal looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Calculate diff and map to each actions
let insertionIndexPaths = diff.insertions.map({ IndexPath(row: $0.idx, section: self.sectionIndex) })
let deletionIndexPaths = diff.deletions.map({ IndexPath(row: $0.idx, section: self.sectionIndex) })
 
// Perform action
tableView.beginUpdates()
tableView.insertRows(at: insertionIndexPaths, with: insertionAnimation)
tableView.deleteRows(at: deletionIndexPaths, with: deletionAnimation)
tableView.endUpdates()
</code></pre></div></div>

<p>^ see that. Really simple for use. If you calculate the diff <strong>manuallyÂ </strong>by your hand and your pencil, itâ€™s really tricky and risky. If itÂ go wrong, your app might crash completelyÂ and youâ€™re fired =)). BraceÂ yourself</p>

<h2 id="1-whats-classic-lcs-">1. Whatâ€™s classic LCS ?</h2>

<p>Given 2 string, find the length of Longest Common Subsequence (LCS) which present in both of them.Â Â A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.</p>

<p>Example, we have string X = â€œABCDEFGâ€. So â€œABDâ€, â€œACDâ€, â€œAFGâ€, â€œCEFBâ€, â€œFGâ€, â€¦. is one of subsequence of X.</p>

<p>But â€œAEDâ€, â€œEBAâ€, â€œGFEDAâ€ â€¦ isnâ€™t correct, because it must be same order.</p>

<p>So a string with n length, will have nÂ² substrings which can construct possible.</p>

<p>LCS of â€œABCDEFâ€ and â€œATDEXFâ€ is ADEF, length = 4</p>

<p>LCS of â€œABCâ€ and â€œAXYZCâ€ is AC, length = 2</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/Longest-Common-Subsequence-example.jpg" alt="" /></p>

<p>or A = â€œacbaedâ€, B = â€œabcadfâ€ =&gt; LCS is â€œacadâ€, length = 4</p>

<p>Â </p>

<p>Â </p>

<p>Â </p>

<h2>Â </h2>

<p>Â </p>

<p>Â </p>

<p>Â 
Â </p>

<p>Before walking into Implementation and Explanation section. It would be better if youÂ try putting your hand in real shit.</p>

<p>Donâ€™t worry about performance or Big(O) yet, just finish it by yourself.</p>

<p>You can try online at <a href="https://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence">HackerRank</a>Â with real test-cases ğŸ˜‰</p>

<p><strong>if you donâ€™t have enough patient, just scroll down and Â keep reading</strong>ğŸ˜ª</p>

<p>Â </p>

<hr />

<p>Â </p>

<p>Â </p>

<p>Â </p>

<h2 id="11-naive-approach">1.1 Naive approach</h2>

<p>The naive solution we can think in our mind is: Iterate through each character in both of string, and compare each result to get final LCS.</p>

<p>In given string A with length = n, it might take O(2<sup>n</sup>) time to complete. It still work without problem if the string is short, but in particular situation, Â itâ€™s really nightmare if we haveÂ very long long text.</p>

<p>Donâ€™t worry about it at this time, I will come to naive approach firstly, by using bottom-up recursion.</p>

<p>If we come with recursion, two important things we shouldÂ to defined is** sub-problem** and <strong>base-recursion(exit)</strong></p>

<h3 id="sub-problem">Sub-problem</h3>

<p><strong>Case 1: Both of character is same.</strong></p>

<p>Example: Given â€œADFGTâ€ and â€œAFOXTâ€</p>

<p>We start from bottom, so we get â€œTâ€ from the first one and â€œTâ€ from the second one.</p>

<p>Itâ€™s match then T <strong>must be a part of LCS</strong>, so we count up by 1. Then we remove both of those, and run recursive continently.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Case 1 - both characters are matched</span>
<span class="kt">LCS</span><span class="p">(</span><span class="s">"ADFGT"</span><span class="p">,</span> <span class="s">"AFOXT"</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kt">LCS</span><span class="p">(</span><span class="s">"ADFG"</span><span class="p">,</span> <span class="s">"AFOX"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Case 2: Pair of character isnâ€™t match:</strong></p>

<p>Given Â â€œADFGâ€ and â€œAFOXâ€, and as we see</p>

<p>â€œGâ€ != â€œXâ€</p>

<p>It means GÂ maybe part of LCS between â€œADF<strong>G</strong>â€ and â€œAFOâ€</p>

<p>or X could be part of LCS between â€œADFâ€ andÂ â€œAFO<strong>X</strong>â€</p>

<p>We donâ€™t know which case is correct.Â So we should call recursion on two possible case and compare the get max value. We can write down like here</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LCS("ADFG", "AFOX") = Max(LCS("ADF", "AFOX"), LCS("ADFG", "AFO"))
</code></pre></div></div>

<h3 id="summarize">Summarize</h3>

<p>Give 2 string A[0..i-1], and B[0..j-1] with i and j is length of AÂ andÂ B</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define findLCS func</span>
<span class="kd">func</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">B</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="kt">A</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="kt">B</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
 
<span class="c1">// Case 1</span>
<span class="kt">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
 
<span class="c1">// Case 2</span>
<span class="kt">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kt">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MAX</span><span class="p">(</span><span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
</code></pre></div></div>

<h3 id="base-recursion-exit">Base recursion (exit)</h3>

<p>So, how about exit recursion ? If youâ€™re working on recursion functionality, please, donâ€™t forget the EXIT.</p>

<p>Itâ€™s same habit when you come to largeÂ building, like CVC cinema or luxury mall, look a EXIT way firstly. In-case of fire, we can get out quickly, and saveÂ your life. Itâ€™s one of must-have survival skill in modern world. So do the same things with Recursion too ğŸ˜‡</p>

<p>Really to figure it out when we should stop: either if any string become <strong>empty string.</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define findLCS func</span>
<span class="kd">func</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">B</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="kt">A</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="kt">B</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
 
<span class="c1">// Case 1</span>
<span class="kt">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
 
<span class="c1">// Case 2</span>
<span class="kt">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kt">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MAX</span><span class="p">(</span><span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="nf">findLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kt">B</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
</code></pre></div></div>

<h2 id="12-problem">1.2 Problem</h2>

<p>Imagination is really hard, so I will draw a tree to see whatâ€™s behind the scene.</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_13.png" alt="" /></p>

<p>^ As you can see, there are few sub-problems has been solved manyÂ times. Time complexity is O(2<sup>n</sup>) in worse case when all character of X and Y are mismatch. It will be <a href="https://en.wikipedia.org/wiki/Exponential_growth">exponential</a> by time.</p>

<p>In next section, we should come up with <strong>Dynamic Programming</strong> approach.</p>

<p>Here is swift code</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hack convention</span>
<span class="c1">// Don't mess up with Range from Swift 3</span>
<span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">charAt</span><span class="p">(</span><span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">((</span><span class="k">self</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="nf">character</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">i</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">/////////////////////////////</span>
<span class="c1">// NAIVE APPROACH</span>
<span class="c1">/////////////////////////////</span>
<span class="c1">// Recurvise func to length of LCS</span>
<span class="kd">func</span> <span class="kt">LCS</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">{</span>
    
    <span class="c1">// Exit</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
        <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">b</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    
    <span class="c1">// Prepare</span>
    <span class="k">let</span> <span class="nv">lengthA</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
    <span class="k">let</span> <span class="nv">lengthB</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
    <span class="k">let</span> <span class="nv">aIndex</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">endIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">bIndex</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">endIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
 
    <span class="c1">// Sub-problem</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="nf">charAt</span><span class="p">(</span><span class="n">lengthA</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="nf">charAt</span><span class="p">(</span><span class="n">lengthB</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// MATCH</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="kt">LCS</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nf">substring</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">aIndex</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="nf">substring</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">bIndex</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// NOT MATCH</span>
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="kt">LCS</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nf">substring</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">aIndex</span><span class="p">),</span> <span class="n">b</span><span class="p">),</span> <span class="kt">LCS</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="nf">substring</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">bIndex</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>
 
 
<span class="c1">// Test</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="s">"acbaed"</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="s">"abcadf"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">LCS</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="c1">// 4</span>
 
<span class="c1">// Unicode</span>
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="s">"ğŸ˜‡ğŸ™ŒğŸ˜‰ğŸ’°ğŸ¹"</span>
<span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="s">"ğŸ™ŒğŸ’ğŸ’°âœˆï¸ğŸ¹ğŸ˜ğŸ”´"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">LCS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="c1">// 3</span>
</code></pre></div></div>
<p><a href="https://github.com/NghiaTranUIT/LCS-Swift/blob/master/LCS-Naive-Solution-Part-1.playground/Contents.swift">Swift Playground on github</a></p>

<h2 id="2-dynamic-programming">2. Dynamic Programming</h2>

<p>Basically, we will use two-dimension array to store the result, reduce time calculate, and reused the resultÂ when ever needed. This technique call Â asÂ Memorization.</p>

<p>Using memorization table is really useful to avoid Overlapping Substructure when design algorithm, we reused result which calculated before, rather computed over and over. But what is the trade-off ?</p>

<ol>
  <li><strong>It cost more space in memory</strong>. If string is Unicode, it also cost more space thanÂ ASCII, but if the goal of solution is aiming to time-complexity, soÂ memorization-table is best choice right now.</li>
  <li>If we implement on low-end computer, it means we have limited memory, so we should consider carefully to apply this approach. MaybeÂ slow a bit by using Recursion will be better, and acceptable.</li>
</ol>

<p>Talk enough, please show me your code ğŸ˜ª</p>

<h3 id="21-memorization-table">2.1 Memorization table</h3>

<p>I will visualize the table step by step now. We will use same given input string from section 1.</p>

<p>A = â€œADFGTâ€ and B = â€œAFOXTâ€, and m is A.length(), n = B.length()</p>

<table>
  <tbody>
    <tr>
      <td>Create two-dimension LCSÂ = [m + 1][n + 1], fill with zero if i == 0</td>
      <td>Â </td>
      <td>j == 0</td>
    </tr>
  </tbody>
</table>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_1.png" alt="" /></p>

<p>The reason why we fill the zero, because the empty string â€œâ€ maybe is LCS as well.</p>

<p>Following twoÂ equation we summarized before, but this time, we donâ€™t use recursion, we use 2 nested-loop, and define LCS as 2-dimension array (filled with 0). But still retain the same philosophy.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defind LCS array (filled with 0 firstly)</span>
<span class="k">var</span> <span class="nv">LCS</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nv">count</span><span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">var</span> <span class="nv">j</span> <span class="o">=</span> <span class="mi">1</span>
 
<span class="c1">// Case 1: Match</span>
<span class="kt">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kt">LCS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
 
<span class="c1">// Case 2: Not Match</span>
<span class="kt">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kt">MAX</span><span class="p">(</span><span class="kt">LCS</span><span class="p">([</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="kt">LCS</span><span class="p">(</span><span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
</code></pre></div></div>

<p>Here is the visualize of them</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_2.png" alt="" />
<img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_4.png" alt="" /></p>

<p>Simple afÂ right? Â ğŸ˜‰</p>

<p>We start to iterate over table with i = 1, and j = 1. We have A[i â€“ 1] == â€œAâ€, B[j â€“ 1] == â€œAâ€ =&gt; It matches, so we do Case 1</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_5.png" alt="" /></p>

<p>=&gt; LCS[1][1] = 1 + LCS[0][0] = 1</p>

<p>Continue with i = 1, j = 2. We compare A[i â€“ 1] != B[j â€“ 1] =&gt; â€œAâ€ != â€œFâ€ =&gt; We do Case 2.</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_6.png" alt="" /></p>

<p>Yeah, so can see, by following case 2, we will compare the value of LCS[1][1] and LCS[0][2].</p>

<p>We have 1 &gt; 0 =&gt; we get <strong>1</strong> as a result, then store in LCS[1][2].</p>

<p>LCS[1][2] = max(LCS[1][1], LCS[0][2])</p>

<p>Keep computing by your hand + brain to the rest of table.</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_7.png" alt="" /></p>

<p>=&gt; See that ğŸ˜‰ just do it with case 1 again</p>

<p>Until the end.</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_8.png" alt="" /></p>

<p>Finally, we got it. So the LengthÂ of LCS is 3.</p>

<p>We havenâ€™t stopped at here yet, because the goal of LCS doesnâ€™t stop at print the length of LCS. We should print out the LCS it-self.</p>

<h3 id="22-print-lcs">2.2 Print LCS</h3>

<p>To print LCS inÂ memorization table is tricky. Because we should tracebackÂ the table again, from the <strong>bottom corner</strong> to the <strong>top corner</strong> where weâ€™ve started, by following new simplest rules.</p>

<ul>
  <li>if A[i] == B[j] =&gt; It means, this element must be a part of LCS, so we print it, we will go to diagonal (means last charÂ­acÂ­ter of both string has matched, so we reduce the length of both the strings by 1, so we move diagÂ­oÂ­nally)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_9.png" alt="" /></p>

<ul>
  <li>if A[i] != B[j], we have two sub-case here. Please check my code</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Max</span><span class="p">(</span><span class="kt">LCS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="k">if</span> <span class="p">(</span><span class="kt">LCS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kt">LCS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">"top"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">"left"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is visualize</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_10.png" alt="" />
<img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_11.png" alt="" /></p>

<p>Keep traceback-ing toÂ the top of memorization table ğŸ¤—. We will have somethings like below. Please notice, the Red Cell is the character we need to store somewhere, because itâ€™s part of LCS.</p>

<p><img src="https://raw.githubusercontent.com/NghiaTranUIT/nghiatranuit.github.io/master/resources/2017/02/table_12.png" alt="" /></p>

<p>The final result is AFT ğŸ™Œ</p>

<h3 id="23-time-complexity">2.3 Time complexity</h3>

<h3 id="naive-solution">Naive solution</h3>

<p>Because we list all possible pair of sub-string between given A and B, and have many overlap sub-problem.</p>

<p>It costs O(2<sup>n</sup>).</p>

<p>It has big problem if the length of text is really long. Because the time complexity is grow quadratically. So let imagine, if we do trivial naive approach, and we have 64Â character, seem we must make comparison up to 2^64 times. It becomes big deal.</p>

<h3 id="dynamic-programming">Dynamic Programming</h3>

<p>By using memorization table to store value calculated, we save a lot of time here. In the implementation code, we only use 2 loop nested.</p>

<p>It costs O(nÂ²).</p>

<p>Given 64 character string, we have 64^64 = <strong>4096</strong> vsÂ 2^64 =Â <strong>1.8E19</strong></p>

<p>SeemÂ O(nÂ²) looksÂ bad, but itâ€™s better 1000â€¦x thanÂ O(2<sup>n</sup>).</p>

<h2 id="24-improvement">2.4 Improvement</h2>

<h3 id="reduce-the-problem-set">Reduce the problem set</h3>

<p>In most of real-world scenario, <strong>the beginning and the ends of file rarely changed.Â </strong>If only few string in middle of texts are changed, we can remove/reduce the begin and end.</p>

<p>By reducing or bounding the upper/lower limitation, we can save tons of memory andÂ comparison time.</p>

<p>Here is presudo-code</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="kt">TrimLCS</span><span class="p">(</span><span class="kt">A</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">B</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">aEnd</span> <span class="o">=</span> <span class="kt">A</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">bEnd</span> <span class="o">=</span> <span class="kt">B</span><span class="o">.</span><span class="nf">length</span><span class="p">()</span>
 
    <span class="c1">// Get index of beginning of file</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">aEnd</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">bEnd</span> <span class="o">&amp;&amp;</span> <span class="kt">A</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
 
    <span class="c1">// Get index of End of file</span>
    <span class="k">while</span> <span class="n">start</span> <span class="err">â‰¤</span> <span class="n">aEnd</span> <span class="n">and</span> <span class="n">start</span> <span class="err">â‰¤</span> <span class="n">bEnd</span> <span class="n">and</span> <span class="kt">A</span><span class="p">[</span><span class="n">aEnd</span><span class="p">]</span> <span class="o">==</span> <span class="kt">B</span><span class="p">[</span><span class="n">bEnd</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">aEnd</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">bEnd</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> 
 
    <span class="c1">// Trim </span>
    <span class="k">let</span> <span class="nv">newA</span> <span class="o">=</span> <span class="kt">A</span><span class="o">.</span><span class="nf">trim</span><span class="p">(</span><span class="n">start</span><span class="o">..</span><span class="n">aEnd</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">newB</span> <span class="o">=</span> <span class="kt">B</span><span class="o">.</span><span class="nf">trim</span><span class="p">(</span><span class="n">start</span><span class="o">..</span><span class="n">bEnd</span><span class="p">)</span>
 
    <span class="c1">// Keep doing LCS algorithm here</span>
    <span class="k">for</span> <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="reduce-the-comparison-time">Reduce the comparison time</h3>

<p>The most of time costs in naive which come from comparison between two characters. In some case, such as source code diff, we only want to see new line, we donâ€™t need to see each difference character. By comparingÂ long text, seem be more effience</p>

<h3 id="turn-string-to-hashes">Turn string to hashes</h3>

<p>Instead of storing long raw string, we may consider to hash or checksum. If the textâ€™s length from 60 or longer, the hash and checksum will turn it shortly, might be only 8-40 character.</p>

<p>Yeah, how about drawback in HashmapÂ ? ğŸ¤”</p>

<ol>
  <li>We need more time to preprocess from both of string.</li>
  <li>We need more space to be allocated forÂ Hashmap</li>
  <li>Collision in Hashmap. Since the checksum or HashmapÂ isnâ€™tÂ guarantee to be unique. There are smallÂ chance two value could be reduced to same hash.</li>
</ol>

<p>Finally, itâ€™s depend on your requirement or place the algorithm will execute. If youâ€™re going to implement LCS on high-end computer, with endless memory, but have limited speed, we should consider about time complexity.</p>

<p>Orthewise, if on low-end device, with really small memory, please take a look a space complexity ğŸ™Œ</p>

<h2 id="3-swift-">3. Swift ?</h2>

<p>Instead of implement original solution. It means only work with String. We should put more effort, and make a extension on Array. It might be difficult to understand a bit, but LCS can work with custom model as well.</p>

<p>If youâ€™re not familiar with Generic, Equatable, Element in Array. Donâ€™t hesitate to spend 30 minutes to review base-foundation in <a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179">SwiftÂ Documentation</a></p>

<p>The extension look like below.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//// Extension of Array</span>
<span class="c1">// But we must ensure, each element must adopt with &lt;Equatable&gt; protocol -&gt; We can make comparision</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{}</span>
</code></pre></div></div>

<h3 id="memorization-table">Memorization table</h3>

<p>The first thing is Memorization table. Please take a look at visualization I draw at previous section.</p>

<p>We create table: [[Element]] and run two nested loop, and calculate the length of LCS by following 2 case: MATCH and NOT MATCH</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Memorization table</span>
<span class="kd">struct</span> <span class="kt">MemorizationTable</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">{</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">buildTable</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">],</span> <span class="nv">y</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span> <span class="p">{</span>
        
        <span class="c1">// Create 2-dimension table, and filled with zero</span>
        <span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span>
        <span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">count</span>
        <span class="k">var</span> <span class="nv">table</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nv">count</span><span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
        <span class="c1">// Iterate from top-left corner -&gt; bottom-right corner</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="n">m</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// MATCH</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span> <span class="c1">// NOT MATCH</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">table</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The code above is really simple af. Just following the table on your notebook, imagine how the i,j iterate over table, check case 1, case 2, move on to next cell.</p>

<h3 id="lcs-with-generic-array">LCS with generic Array</h3>

<p>Itâ€™s really tricky to run recursion from bottom corner to the top. Itâ€™s same approach I mention in section 2.2.</p>

<ul>
  <li>Start from Bottom</li>
  <li>If x[i] == y[j] // Match -&gt; MoveÂ diagÂ­oÂ­nally</li>
  <li>else, we check ifÂ table[i-1][j] &gt; table[i][j-1] -&gt; Go Top</li>
  <li>else Go Left ğŸ˜</li>
</ul>

<p>Here is detail code. I tried to write simple as possible. Please noticeÂ <strong>lcsFromMemorizationTable</strong>Â is private method. Because I donâ€™t want people modify it.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//// Extension of Array</span>
<span class="c1">// But we must ensure, each element must adopt with &lt;Equatable&gt; protocol -&gt; We can make comparision</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    
    <span class="kd">func</span> <span class="kt">LCS</span><span class="p">(</span><span class="n">_</span> <span class="nv">other</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">]</span> <span class="p">{</span>
        
        <span class="c1">// Build memorization table</span>
        <span class="k">let</span> <span class="nv">table</span> <span class="o">=</span> <span class="kt">MemorizationTable</span><span class="o">.</span><span class="nf">buildTable</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">other</span><span class="p">)</span>
        
        <span class="c1">// Print LCS</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">lcsFromMemorizationTable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">lcsFromMemorizationTable</span><span class="p">(</span><span class="n">_</span> <span class="nv">table</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]],</span> <span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">],</span> <span class="n">_</span> <span class="nv">y</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">],</span> <span class="n">_</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">j</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">]</span> <span class="p">{</span>
        
        <span class="c1">// Exit</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="p">}</span>
        
        <span class="c1">// Recurvise </span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// MATCH -&gt; Get element</span>
            <span class="k">return</span> <span class="nf">lcsFromMemorizationTable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Top</span>
            <span class="k">return</span> <span class="nf">lcsFromMemorizationTable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="c1">// Left</span>
            <span class="k">return</span> <span class="nf">lcsFromMemorizationTable</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="test-with-string">Test with string</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////////////////////////</span>
<span class="c1">////// TEST with string</span>
 
<span class="c1">// Convert [CharacterView] -&gt; [String]</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="s">"acbaed"</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)}</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="s">"abcadfa"</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)}</span>
 
<span class="k">let</span> <span class="nv">lcs</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="kt">LCS</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">//</span>
<span class="nf">print</span><span class="p">(</span><span class="n">lcs</span><span class="p">)</span> <span class="c1">//  ["a", "b", "a", "d"]</span>
</code></pre></div></div>

<p>Because LCS is working with Array<Element>, so we need to map [CharacterView] -&gt; [String].</Element></p>

<h3 id="test-with-array-of-custom-model">Test with array of Custom model</h3>

<p><strong>UserObj</strong> is custom struct, or any kind of class.Â The different thing, we must adopt Equatable.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">UserObj</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span>
 
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"{</span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">name</span><span class="o">!</span><span class="se">)</span><span class="s">}"</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// Adopt Equatable</span>
<span class="kd">extension</span> <span class="kt">UserObj</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">UserObj</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">UserObj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Donâ€™t forget to adopt <Equatable> protocol. If you donâ€™t do this. Swift canâ€™t understand how to make a comparison between **UserObj.**</Equatable></p>

<p>Actually, even if you wonâ€™t do it onÂ purpose, XCode will shot you an error intermediately, at build-time âŒ. Itâ€™s one reason why I really love Swift â€“ type safe language ğŸ¤—</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">localUsers</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Nghia Tran"</span><span class="p">),</span>
                  <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"nghiatran.me"</span><span class="p">),</span>
                  <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SaiGon"</span><span class="p">),</span>
                  <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Algorithm"</span><span class="p">)]</span>
<span class="k">let</span> <span class="nv">remoteUsers</span> <span class="o">=</span> <span class="p">[</span><span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Kamakura"</span><span class="p">),</span>
                   <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Nghia Tran"</span><span class="p">),</span>
                   <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Algorithm"</span><span class="p">),</span>
                   <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SaiGon"</span><span class="p">),</span>
                   <span class="kt">UserObj</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Somewhere"</span><span class="p">)]</span>
 
<span class="k">let</span> <span class="nv">lcsUser</span> <span class="o">=</span> <span class="n">localUsers</span><span class="o">.</span><span class="kt">LCS</span><span class="p">(</span><span class="n">remoteUsers</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">lcsUser</span><span class="p">)</span> <span class="c1">// [{Nghia Tran}, {Algorithm}]</span>
</code></pre></div></div>
<p><a href="â€https://github.com/NghiaTranUIT/LCS-Swift/blob/master/LCS-Dynamic-Programming-Part-1.playground/Contents.swift">Swift playground on github</a></p>

<h2 id="4-where-to-go-from-here">4. Where to go from hereÂ ?</h2>

<p>You can download full source here</p>

<p><a href="https://github.com/NghiaTranUIT/LCS-Swift">Github</a></p>

<p>In this blog, weâ€™ve learn how LCS algorithm actually works, how we can visualize it step by step, and how we implement LCS for generic Array in Swift too ğŸ˜</p>

<p>In next blog, I will cover how we can apply LCS to iOS development, especially in UITableView and UICollectionView. How we can optimize â€œthe transformâ€ from DataSourceA to DataSourceB without callingÂ reloadData().</p>

<p>Thank everybody for reading and blow up your brain ğŸ‘»</p>

:ET